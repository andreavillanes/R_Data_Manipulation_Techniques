[["data-structures.html", "Chapter 2 Data Structures 2.1 Vectors 2.2 Lists 2.3 Arrays 2.4 Matrices 2.5 Data Frames 2.6 Working with different types", " Chapter 2 Data Structures 2.1 Vectors A vector is the simplest type of data structure in R. Vectors are particularly important as most of the functions you will write will work with vectors. Simply put, a vector is a sequence of data elements of the same basic type. We can construct a vector using the combine (c) function: &gt; # Here is a vector containing three numeric values 3, 5 and 7: &gt; numbers &lt;- c(3, 5, 7) &gt; &gt; #Here is a vector of logical values: &gt; logical &lt;- c(TRUE, FALSE, TRUE, FALSE, FALSE) &gt; &gt; #Here is a vector of character values: &gt; fruits &lt;- c(&quot;apple&quot;, &quot;oranges&quot;, &quot;banana&quot;) We can also change the value in a vector: &gt; fruits[2] &lt;- &quot;strawberries&quot; Every vector has two key properties: its type and its length: &gt; typeof(fruits) &gt; length(fruits) You can combine vectors using the combine function as well: &gt; results &lt;- c(1, 2, 3) &gt; other_results &lt;- c(4, 5, 6) &gt; combined_results &lt;- c(results, other_results) Vectors can be added together in an element-wise operation: &gt; total_add &lt;- results + other_results &gt; total_div &lt;- results / other_results &gt; total_mod &lt;- results %% other_results Functions can be applied to each element of the vector. However, not all functions are vectorized (we will cover this later): &gt; total_rou &lt;- round(total_div, 1) &gt; &gt; names &lt;- c(&quot;Simmons&quot;, &quot;Race&quot;, &quot;Healey&quot;, &quot;LaBarr&quot;, &quot;Villanes&quot;) &gt; names &lt;- sort(names, decreasing = TRUE) There are also functions for constructing useful types of vectors: &gt; # Replicate - replicates a value X number of times &gt; identity_vector &lt;- rep(1,10) &gt; identity_vector &gt; &gt; # Sequence operator &quot;:&quot; From:To &gt; sequence_vector &lt;- 1:10 &gt; &gt; # Sequence function - allows sequencing by a value &gt; sequence_by_two_vector &lt;- seq(0,10, 2) &gt; sequence_by_two_vector &gt; &gt; # Sample function - take a random sample from a vector &gt; random_vector &lt;- sample(sequence_by_two_vector,3) &gt; &gt; #A common trick to randomly permute all elements in a vector is sample(vector_name) &gt; permute &lt;- sample(numbers) Finally, a vector doesnt have to be made with consistent elements, but it will force them to one type: &gt; values &lt;- c(&quot;IAA&quot;, 1, &quot;2021&quot;, 5) &gt; typeof(values) As we mentioned earlier, the elements of a vector can only be of one type. If we want elements of different types we will need a list. 2.2 Lists Lists are objects which contain elements of different types like  numbers, strings, vectors and another list inside it. A list can also contain a matrix or a function as its elements. A list is created using list() function. &gt; # Here are 3 vectors of different types &gt; v1 &lt;- c(&quot;apple&quot;, &quot;banana&quot;) &gt; v2 &lt;- c(&quot;dog&quot;, &quot;cat&quot;, &quot;bunny&quot;, &quot;pig&quot;, &quot;cow&quot;, &quot;horse&quot;) &gt; v3 &lt;- seq(0,10,by=2) &gt; &gt; v1;v2;v3 We can put all of these vectors into a list: &gt; # Here are 3 vectors of different types &gt; l1 &lt;- list(v1, v2, v3) &gt; &gt; class(l1) &gt; typeof(l1) List elements can be accessed via index. Each of the components of a list is accessed via the double bracket [[x]] syntax: &gt; # First element in the list &gt; l1[[1]] &gt; &gt; # First element in the first element (vector) of the list &gt; l1[[1]][1] List elements can be named: &gt; names(l1) &lt;- c(&quot;Fruit&quot;, &quot;Animals&quot;, &quot;Even_Numbers&quot;) Or they can be named upon creating the list: &gt; l1 &lt;- list(Fruit=v1, Animals=v2, Even_Numbers=v3) The elements in a list can be retrieved by name: &gt; l1$Fruit &gt; l1$Fruit[1] &gt; &gt; l1$Even_Numbers &gt; max(l1$Even_Numbers) A list can even contain lists: &gt; l2 &lt;- list(Odd_Numbers=seq(1,10,by=2), list1=l1) &gt; &gt; # First Vector &gt; l2$Odd_Numbers &gt; l2[[1]] &gt; &gt; # l1 within L2 &gt; l2$list1 &gt; l2[[2]] &gt; &gt; l2$list1$Fruit &gt; l2[[2]][1] &gt; &gt; l2$list1$Fruit[1] &gt; l2[[2]][[1]][1] &gt; &gt; l2[[2]][[1]][3] &lt;- &quot;blueberry&quot; &gt; l2$list1$Fruit &gt; l2 To combine lists: &gt; l4 &lt;- list(More_Fruit=c(&quot;melon&quot;, &quot;orange&quot;)) &gt; l1 &lt;- c(l1,l4) Finally, if we want to update part of a list, we can just operate on and update it accordingly: &gt; l1$Fruit &lt;- c(l1$Fruit, l4$More_Fruit) &gt; l1$Fruit 2.3 Arrays Arrays are similar to vectors, except that they are multi-dimensional. An array is created using the array() function, and the dim parameter to specify the dimensions: &gt; # 1 dimension - 1 row (vector) &gt; sequence_array_1_dim &lt;- array(1:10, dim=10) &gt; sequence_array_1_dim &gt; &gt; # 2 dimensions - 2 rows, 5 columns &gt; sequence_array_2_dim &lt;- array(1:10, dim= c(2,5)) &gt; sequence_array_2_dim &gt; &gt; # 3 dimensions - 2 rows, 5 columns, 2 tables &gt; sequence_array_3_dim &lt;- array(1:20, dim = c(2,5,2)) &gt; sequence_array_3_dim &gt; &gt; # 4 dimensions - 2 rows, 5 columns, 2 tables, 2 sets &gt; sequence_array_4_dim &lt;- array(1:40, dim = c(2,5,2,2)) &gt; sequence_array_4_dim Similar to vectors, functions can be applied to arrays: &gt; dim(sequence_array_2_dim) &gt; length(sequence_array_2_dim) &gt; sum(sequence_array_2_dim) &gt; max(sequence_array_2_dim) 2.4 Matrices Matrices are objects in which the elements are arranged in a two-dimensional rectangular layout. A matrix is created using the matrix() function: &gt; # A matrix is a 2-demensional (row x column) array &gt; A &lt;- matrix(1:25, 5, 5) &gt; &gt; B &lt;- matrix(1:25, 5, 5, byrow=TRUE) #if you want to fill down the row instead of across the columns &gt; &gt; C &lt;- matrix(1:5, 1, 5) &gt; &gt; D &lt;- matrix(1:5, 5, 1) Matrices are convenient because we can do linear algebra with them: &gt; # Element-wise operators &gt; A + B &gt; A - B &gt; A * B &gt; A / B &gt; &gt; # Matrix Multiplication &gt; C %*% D &gt; &gt; # Transpose &gt; C &gt; t(C) We can also name the matrix columns and and rows: &gt; colnames(A) &lt;- c(&quot;Column_1&quot;, &quot;Column_2&quot;, &quot;Column_3&quot;, &quot;Column_4&quot;, &quot;Column_5&quot;) &gt; A &gt; &gt; colnames(A)[4] &lt;- &quot;Changed_It&quot; &gt; A &gt; &gt; rownames(A) &lt;- c(&quot;Row_1&quot;, &quot;Row_2&quot;, &quot;Row_3&quot;, &quot;Row_4&quot;, &quot;Row_5&quot;) &gt; A We can also use some helpful functions for matrices: &gt; colSums(A) &gt; rowSums(A) &gt; sum(A) &gt; dim(A) &gt; length(A) And we can extract information from a matrix using similar index notation (row, column): &gt; A[2,1] # Single element &gt; &gt; A[,1] # All rows in the first column &gt; A[,c(1,2)] # All rows for columns 1 and 2 &gt; &gt; A[1,] # All columns in the first row &gt; A[c(1,2),] # All columns for rows 1 and 2 &gt; &gt; A[&quot;Row_1&quot;,&quot;Column_2&quot;] 2.5 Data Frames Data Frames are data displayed in a format as a table. A data frame is essentially a 2 dimensional matrix (row x column). You can think of it like an excel table or relational database table. Data Frames can have different types of data inside it, and we use the data.frame() function to create a data frame: &gt; # Create a data frame called dt1 from a set of vectors: &gt; dt1 &lt;- data.frame ( + names = c(&quot;Simmons&quot;, &quot;Race&quot;, &quot;Healey&quot;, &quot;LaBarr&quot;, &quot;Villanes&quot;), + class = c(&quot;Time Series&quot;, &quot;Linear Algebra&quot;, &quot;Visualization&quot;, &quot;Finance&quot;, &quot;Programming&quot;), + female = c(1,1,0,0,1) + ) To view the data frame: &gt; # View the table &gt; View(dt1) &gt; &gt; # Head of the table &gt; head(dt1, 3) To change the column names: &gt; colnames(dt1) &gt; colnames(dt1) &lt;- c(&quot;Last_Name&quot;, &quot;Class_Taught&quot;, &quot;Female?&quot;) &gt; colnames(dt1) &gt; colnames(dt1)[2] &lt;- &quot;Classes_Taught&quot; &gt; colnames(dt1) To reference a column by name: &gt; dt1$Last_Name &gt; dt1$Classes_Taught Data frame indexes - similar to vectors and arrays. We can perform the following actions: &gt; # Retrieve a row &gt; # leaving the row or column blank means &quot;everything&quot; &gt; # the negative operator &quot;-&quot; means &quot;everything but&quot; &gt; dt1[1,] &gt; dt1[2:5,] &gt; dt1[-1,] &gt; &gt; # Retrieve a column &gt; dt1[,1] &gt; dt1[,-3] &gt; dt1[,c(1:2)] &gt; dt1[,&quot;Last_Name&quot;] &gt; dt1[,c(&quot;Last_Name&quot;,&quot;Female?&quot;)] &gt; &gt; # Retrieve an element &gt; dt1[6,2] &gt; &gt; # Reassign an element &gt; dt1[5,2] &lt;- &quot;R Programming&quot; &gt; dt1[5,] &gt; &gt; #Find elements that meet a condition &gt; dt1$`Female?`==1 &gt; dt1$Last_Name==&#39;Race&#39; &gt; &gt; # Filter by an value &gt; dt1[dt1$`Female?`==1,] &gt; dt1[dt1$Last_Name==&#39;Race&#39;,] &gt; &gt; # Add a new row - rbind (row-bind) function. The cbind function is its column version. &gt; dt1 &lt;- rbind(dt1, c(&quot;Larsen&quot;, &quot;Teaching Assistant&quot;, 0)) &gt; dt1 &gt; &gt; # Add a new column &gt; dt1$First_Name &lt;- c(&quot;Susan&quot;, &quot;Shaina&quot;, &quot;Christopher&quot;, &quot;Aric&quot;, &quot;Andrea&quot;, &quot;Nicholas&quot;) &gt; &gt; # Change the order of columns &gt; dt1 &lt;- dt1[,c(4,1:3)] &gt; &gt; # Make columns based off other columns &gt; dt1$First_Name_Length &lt;- nchar(dt1$First_Name) &gt; dt1$Last_Name_Length &lt;- nchar(dt1$Last_Name) &gt; dt1$Total_Name_Length &lt;- dt1$First_Name_Length + dt1$Last_Name_Length + 1 &gt; dt1$Full_Name &lt;- paste(dt1$First_Name, dt1$Last_Name, sep=&quot; &quot;) &gt; dt1 &gt; &gt; # Remove some intermediate step columns &gt; dt1 &lt;- dt1[,-c(5,6)] 2.6 Working with different types We can examine the class of each object using the class function: &gt; total_add &gt; class(total_add) &gt; &gt; names &gt; class(names) &gt; &gt; l2 &gt; class(l2) &gt; &gt; sequence_array_1_dim &gt; class(sequence_array_1_dim) &gt; &gt; A &gt; class(A) &gt; &gt; dt1 &gt; class(dt1) &gt; &gt; dt1$First_Name &gt; class(dt1$First_Name) Finally, we can also do some conversions between them using the as functions: &gt; new_array &lt;- as.array(total_add) &gt; class(new_array) &gt; &gt; old_vector &lt;- as.vector(new_array) &gt; class(old_vector) &gt; &gt; dfA &lt;- as.data.frame(A) &gt; class(dfA) "]]
