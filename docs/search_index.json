[["data-wrangling.html", "Chapter 4 Data Wrangling 4.1 Libraries 4.2 Importing &amp; Exporting Data 4.3 dplyr and tidyverse 4.4 Data manipulation - dplyr basics 4.5 dplyr - pipe operator 4.6 stringr package 4.7 Combining Data - dplyr 4.8 Cheat Sheet 4.9 Extra - sqldf", " Chapter 4 Data Wrangling 4.1 Libraries Up until now, we haven’t used packages - only functions available in base R. However, the power of R truly exists in the libraries, which are sets of functions that any user can create and share. As of June 2019, there were over 14,000 packages available on the Comprehensive R Archive Network, or CRAN, the public clearing house for R packages. CRAN lists all libraries here: https://cran.r-project.org/web/packages/available_packages_by_name.html To install a library, you can either: Packages --&gt; Install --&gt; Name Use the function install.packages() Once a package is installed, you need to load it using the library or require function. These are the libraries we’ll be using today. Install if you don’t have: install.packages(c(&quot;data.table&quot;,&quot;dplyr&quot;,&quot;stringr&quot;)) Now, import the libraries: library(data.table) library(dplyr) library(stringr) 4.2 Importing &amp; Exporting Data Before importing data, we generally want to set the working directory. This is a folder where we will be accessing or storing data and outputs: setwd(&quot;C:/Users/avillan/Documents/Class 2022/Class_Code&quot;) Another useful function is getwd(). This function returns an absolute filepath representing the current working directory of the R process, or NULL if the working directory is not available: getwd() To import data, we can use the read. function df_auto &lt;- read.csv(&quot;Auto_MPG.csv&quot;, stringsAsFactors = FALSE) We can check the data set: class(df_auto) View(df_auto) dim(df_auto) nrow(df_auto) summary(df_auto) Note that Horsepower is a character class typeof(df_auto$Horsepower) df_auto$Horsepower summary(df_auto$Horsepower) Upon inspection, it read NAs as question marks (a character), so everything became a character. We can fix this by reassigning as numeric: df_auto$Horsepower &lt;- as.numeric(df_auto$Horsepower) summary(df_auto) df_auto$Horsepower summary(df_auto$Horsepower) Recall if you want to fix a column name you can use the colnames() function: colnames(df_auto) colnames(df_auto)[8] &lt;- &quot;Origin&quot; colnames(df_auto) If we want to export the data, we can use write.csv. The row.names = FALSE argument will stop the writer from outputting a row number: write.csv(df_auto, file=&quot;Auto_MPG_Clean.csv&quot;, row.names = FALSE) In addition to importing the data using code, one can also import data into RStudio with point-and-click. Go to Import Dataset in the Environment panel and select the relevant format. From there, you can set the datatype of each column, as well as specify whether to include or to skip a column or row. RStudio automatically generates the corresponding code that you can copy and paste for later reproducibility. 4.3 dplyr and tidyverse One of the most difficult (yet, interesting!) parts of open-source software is the many ways to achieve the same task. This can make recalling functions and syntax difficult, increasing the time to write or read code. Thus, people have started creating packages that structure coding tasks into a simple but comprehensive set of functions. You’ll see this referred to as a “grammar”. This framework attempts to simplify the majority of required functions into a simple set of “verbs” to remember. If you’re familiar with SQL - think about how easy it is to read and write: SELECT * FROM table WHERE column = 'some_value' In SQL, SELECT, FROM, WHERE are “verbs” that provide the framework for numerous tasks. The packages plyr, dplyr, ggplot2, stringr (and others) work within this framework. “tidyverse” is a collection of packages that encompases all of these https://www.tidyverse.org/ 4.4 Data manipulation - dplyr basics Select: select columns by name or helper function (choose which variables you want to look at ): select(df_auto, MPG, Cylinders) select(df_auto, -Origin) select(df_auto, contains(&quot;Model&quot;)) The base R equivalents are: df_auto$MPG df_auto[,c(&#39;MPG&#39;,&#39;Cylinders&#39;)] df_auto[,-c(&#39;Origin&#39;)] df_auto[,grepl(&quot;Model&quot;, names(df_auto))] Slice: Select rows by position (choose which rows of data you want): df_auto$row_number &lt;- 1:nrow(df_auto) #adding a new variable called row_number to help us see the index slice(df_auto,1:5) slice(df_auto, 150:n()) #all the rows between 150 and the end slice(df_auto, -1:-5) #removes rows between values, equivalent to slice(df_auto, 6:n()) df_auto &lt;- select(df_auto, -row_number) #remove the row_number column The base R equivalents are: df_auto[1:5,] df_auto[150:nrow(df_auto),] df_auto[-c(1:5),] Rename: Rename the columns of a data frame colnames(df_auto) df_auto &lt;- rename(df_auto, Miles_Per_Gallon=MPG) #rename MPG to Miles_Per_Gallon colnames(df_auto) df_auto &lt;- rename(df_auto, MPG=Miles_Per_Gallon) #rename back Miles_Per_Gallon to MPG colnames(df_auto) The base R equivalents are: colnames(df_auto)[1] &lt;- &#39;Miles_Per_Gallon&#39; colnames(df_auto) colnames(df_auto)[1] &lt;- &#39;MPG&#39; colnames(df_auto) Filter: Extract rows that meet logical criteria (filter the data frame by one, or multiple, conditions) filter(df_auto, MPG&gt;20) filter(df_auto, (MPG&gt;20 &amp; Acceleration&gt;20)) filter(df_auto, MPG==max(MPG)) filter(df_auto, MPG==min(MPG)) The base R equivalents are: df_auto[df_auto$MPG&gt;20,] df_auto[(df_auto$MPG&gt;20 &amp; df_auto$Acceleration&gt;20),] df_auto[which.max(df_auto$MPG),] df_auto[which.min(df_auto$MPG),] Sample: Randomly select a sample of n size or a proportion sample_n(df_auto, 5) sample_frac(df_auto, 0.05) The base R equivalents are: df_auto[sample(1:nrow(df_auto),5),] df_auto[sample(1:nrow(df_auto),ceiling(0.05*nrow(df_auto))),] Mutate: Compute and append one or more new columns (create a new variable - returns the data frame) mutate(df_auto, HP_Per_Cylinder=Horsepower/Cylinders) mutate(df_auto, Avg_HP_Per_Cylinder = mean(Horsepower/Cylinders, na.rm=TRUE)) The base R equivalents are: df_auto$HP_Per_Cylinder &lt;- df_auto$Horsepower / df_auto$Cylinders df_auto$Avg_HP_Per_Cylinder &lt;- mean(df_auto$Horsepower / df_auto$Cylinders, na.rm = TRUE) About the na.rm=TRUE argument. Some arithmatic functions sum, avg, count, etc. will NA the entire column if they encounter a single NA within that column/vector. Setting na.rm=TRUE will tell the interpreter to “remove” the NA and carry forth with the calculation. Summarise: Summarise data into single row of values (aggregates the data into a single result. think avg, mean, min, max, etc.) summarise(df_auto, Avg_HP_Per_Cylinder=mean(Horsepower/Cylinders, na.rm = TRUE), Min_HP_Per_Cylinder=min(Horsepower/Cylinders, na.rm=TRUE) ) The base R equivalents are: data.frame( Avg_HP_Per_Cylinder = mean(df_auto$Horsepower/df_auto$Cylinders, na.rm = TRUE), Min_HP_Per_Cylinder = min(df_auto$Horsepower/df_auto$Cylinders, na.rm=TRUE) ) 4.5 dplyr - pipe operator Consider the previous operations. If we wanted to manipulate our data set in order, we traditionally have to do a reassignment each time: df_auto_hold &lt;- rename(df_auto, Miles_Per_Gallon=MPG) #rename df_auto_hold &lt;- mutate(df_auto_hold, HP_Per_Cylinder=Horsepower/Cylinders) #then create df_auto_hold &lt;- filter(df_auto_hold, HP_Per_Cylinder&gt;20) #then filter df_auto_hold &lt;- select(df_auto_hold, Car_Name, HP_Per_Cylinder) #then select View(df_auto_hold) This is truely cumbersome the more complicated the data manipulation becomes. To avoid this, we can use the pipe operator %&gt;%. The pipe “passes along” the results of one function to the next: df_auto_hold &lt;- df_auto %&gt;% #note the pipe operator rename(Miles_Per_Gallon=MPG) %&gt;% #note the first argument is not required, because the pipe is passing it mutate(HP_Per_Cylinder=Horsepower/Cylinders) %&gt;% filter(HP_Per_Cylinder&gt;20) %&gt;% select(Car_Name, HP_Per_Cylinder) View(df_auto_hold) 4.6 stringr package The package stringr is a similar grammar language for manipulating strings. All the functions start with str_ Consider that I want to extract the Car Make and Model from the Car Name: View(df_auto_hold) We note that the first word in Car_Name is the make, and the second word is the model. The str_split function will split the string into a vector of individual tokens: df_auto_hold &lt;- df_auto %&gt;% mutate(Car_Make=str_split(Car_Name,&quot; &quot;)) View(df_auto_hold) The str_split creates a list, which we can use to try to get the value: df_auto_hold &lt;- df_auto %&gt;% mutate(Car_Make=str_split(Car_Name,&quot; &quot;)[[1]][1]) View(df_auto_hold) Note, this is treating the entire column, instead of by row. One way to address this is to rowise() by Car_Name, then create the variable: df_auto_hold &lt;- df_auto %&gt;% rowwise() %&gt;% mutate(Car_Make=str_split(Car_Name,&quot; &quot;)[[1]][1]) View(df_auto_hold) An alternative to this is the group_by() function: df_auto_hold &lt;- df_auto %&gt;% group_by(Car_Name) %&gt;% mutate(Car_Make=str_split(Car_Name,&quot; &quot;)[[1]][1]) View(df_auto_hold) With the structure built, I can just pipe on more functions to get additional variables: df_auto &lt;- df_auto %&gt;% rowwise() %&gt;% mutate(Car_Make=str_split(Car_Name,&quot; &quot;)[[1]][1]) %&gt;% mutate(Car_Model=paste(str_split(Car_Name,&quot; &quot;)[[1]][-1], collapse=&quot; &quot;)) #everything but the first View(df_auto) Now that we have Car Make and Model, we might want to summarize some information. We saw summarize the entire column earlier, but we can additionally summarize by a group. We use the group_by() to do so: # Average MPG by Make and Model Year df_auto %&gt;% group_by(Car_Make, Model_Year) %&gt;% summarise(Average_MPG=mean(MPG)) %&gt;% arrange(Model_Year) %&gt;% filter(Model_Year==70) %&gt;% ungroup(Car_Make, Model_Year) 4.7 Combining Data - dplyr Typically when working with data, especially relational databases, we have information stored in multiple tables. For instance, we have the Auto data set: View(df_auto) # But we also have data on when a brand started: Car_Make &lt;- c(&quot;amc&quot;, &quot;audi&quot;, &quot;bmw&quot;, &quot;buick&quot;, &quot;chevrolet&quot;, &quot;datsun&quot;, &quot;dodge&quot;, &quot;ford&quot;) First_Year &lt;- c(1954, 1910, 1916, 1903, 1911, 1931, 1900, 1903) df_auto_start &lt;- data.frame(Car_Make=Car_Make, First_Year=First_Year, stringsAsFactors = FALSE) View(df_auto_start) We are interested in the relationship between founding year and average MPG for the max year. For this, we need to get my First Year data combined with the Auto MPG Data. This is accomplished via joins. Dplyr has different join types. The easiest way to think about this is as a Venn-Diagram. inner_join - only returns the data where both frames contain the join key(s), removes all non-matching rows left_join - maintains all of the data on base table (left/top), and joins matching data from the joining table. NAs created for joining table right_join - opposite of left. Maintains all of the data on the joining table and matches from the base table. NAs created for base table full_join - returns all data from both tables. NAs created for both tables. Inner_join: df_auto_hold &lt;- df_auto %&gt;% inner_join(df_auto_start, by=&quot;Car_Make&quot;) View(df_auto_hold) # Note, we&#39;ve effectively filtered a lot of data because the inner_join only keeps matching records. dim(df_auto) dim(df_auto_hold) # Joins can pipe together with other functions just as we expect df_auto_hold &lt;- df_auto %&gt;% inner_join(df_auto_start, by=&quot;Car_Make&quot;) %&gt;% group_by(Car_Make, First_Year) %&gt;% summarise(Average_MPG=mean(MPG)) View(df_auto_hold) plot(df_auto_hold$First_Year, df_auto_hold$Average_MPG) Left_join: df_auto_hold &lt;- df_auto %&gt;% left_join(df_auto_start, by=&quot;Car_Make&quot;) # note, we&#39;ve retained all of the records but it&#39;s placed &quot;NA&quot; in the column where it couldn&#39;t find a matching record dim(df_auto) dim(df_auto_hold) is.na(df_auto_hold$First_Year) View(df_auto_hold) df_auto_hold &lt;- df_auto %&gt;% left_join(df_auto_start, by=&quot;Car_Make&quot;) %&gt;% group_by(Car_Make, First_Year) %&gt;% summarise(Average_MPG=mean(MPG)) View(df_auto_hold) 4.8 Cheat Sheet We’re not going to cover every function here, but what is great about these packages is the the cheatsheets. The community has made to provide reference. I highly recommend downloading them and keeping them close: dplyr: https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf stringr: https://github.com/rstudio/cheatsheets/blob/master/strings.pdf a whole lot more… https://www.rstudio.com/resources/cheatsheets/ 4.9 Extra - sqldf If you like SQL, there is a package allows you to manipulate data in a in-memory, or permanent database: install.packages(&quot;sqldf&quot;) library(sqldf) df_auto_hold &lt;- sqldf(&quot;select * from df_auto where Car_Make=&#39;amc&#39;&quot;) View(df_auto_hold) We will learn a lot more about SQL in the Fall semester. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
