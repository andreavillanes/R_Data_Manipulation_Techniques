[["data-structures.html", "Chapter 2 Data Structures 2.1 Vectors 2.2 Lists 2.3 Arrays 2.4 Matrices 2.5 Data Frames 2.6 Working with different types", " Chapter 2 Data Structures 2.1 Vectors A vector is the simplest type of data structure in R. Vectors are particularly important as most of the functions you will write will work with vectors. Simply put, a vector is a sequence of data elements of the same basic type. We can construct a vector using the combine (c) function: # Here is a vector containing three numeric values 3, 5 and 7: numbers &lt;- c(3, 5, 7) #Here is a vector of logical values: logical &lt;- c(TRUE, FALSE, TRUE, FALSE, FALSE) #Here is a vector of character values: fruits &lt;- c(&quot;apple&quot;, &quot;oranges&quot;, &quot;banana&quot;) We can also change the value in a vector: fruits[2] &lt;- &quot;strawberries&quot; Every vector has two key properties: its type and its length: typeof(fruits) length(fruits) You can combine vectors using the combine function as well: results &lt;- c(1, 2, 3) other_results &lt;- c(4, 5, 6) combined_results &lt;- c(results, other_results) Vectors can be added together in an element-wise operation: total_add &lt;- results + other_results total_div &lt;- results / other_results total_mod &lt;- results %% other_results Functions can be applied to each element of the vector. However, not all functions are vectorized (we will cover this later): total_rou &lt;- round(total_div, 1) names &lt;- c(&quot;Simmons&quot;, &quot;Race&quot;, &quot;Healey&quot;, &quot;LaBarr&quot;, &quot;Villanes&quot;) names &lt;- sort(names, decreasing = TRUE) There are also functions for constructing useful types of vectors: # Replicate - replicates a value X number of times identity_vector &lt;- rep(1,10) identity_vector # Sequence operator &quot;:&quot; From:To sequence_vector &lt;- 1:10 # Sequence function - allows sequencing by a value sequence_by_two_vector &lt;- seq(0,10, 2) sequence_by_two_vector # Sample function - take a random sample from a vector random_vector &lt;- sample(sequence_by_two_vector,3) #A common trick to randomly permute all elements in a vector is sample(vector_name) permute &lt;- sample(numbers) Finally, a vector doesnt have to be made with consistent elements, but it will force them to one type: values &lt;- c(&quot;IAA&quot;, 1, &quot;2021&quot;, 5) typeof(values) As we mentioned earlier, the elements of a vector can only be of one type. If we want elements of different types we will need a list. 2.2 Lists Lists are objects which contain elements of different types like  numbers, strings, vectors and another list inside it. A list can also contain a matrix or a function as its elements. A list is created using list() function. # Here are 3 vectors of different types v1 &lt;- c(&quot;apple&quot;, &quot;banana&quot;) v2 &lt;- c(&quot;dog&quot;, &quot;cat&quot;, &quot;bunny&quot;, &quot;pig&quot;, &quot;cow&quot;, &quot;horse&quot;) v3 &lt;- seq(0,10,by=2) v1;v2;v3 We can put all of these vectors into a list: # Here are 3 vectors of different types l1 &lt;- list(v1, v2, v3) class(l1) typeof(l1) List elements can be accessed via index. Each of the components of a list is accessed via the double bracket [[x]] syntax: # First element in the list l1[[1]] # First element in the first element (vector) of the list l1[[1]][1] List elements can be named: names(l1) &lt;- c(&quot;Fruit&quot;, &quot;Animals&quot;, &quot;Even_Numbers&quot;) Or they can be named upon creating the list: l1 &lt;- list(Fruit=v1, Animals=v2, Even_Numbers=v3) The elements in a list can be retrieved by name: l1$Fruit l1$Fruit[1] l1$Even_Numbers max(l1$Even_Numbers) A list can even contain lists: l2 &lt;- list(Odd_Numbers=seq(1,10,by=2), list1=l1) # First Vector l2$Odd_Numbers l2[[1]] # l1 within L2 l2$list1 l2[[2]] l2$list1$Fruit l2[[2]][1] l2$list1$Fruit[1] l2[[2]][[1]][1] l2[[2]][[1]][3] &lt;- &quot;blueberry&quot; l2$list1$Fruit l2 To combine lists: l4 &lt;- list(More_Fruit=c(&quot;melon&quot;, &quot;orange&quot;)) l1 &lt;- c(l1,l4) Finally, if we want to update part of a list, we can just operate on and update it accordingly: l1$Fruit &lt;- c(l1$Fruit, l4$More_Fruit) l1$Fruit 2.3 Arrays Arrays are similar to vectors, except that they are multi-dimensional. An array is created using the array() function, and the dim parameter to specify the dimensions: # 1 dimension - 1 row (vector) sequence_array_1_dim &lt;- array(1:10, dim=10) sequence_array_1_dim # 2 dimensions - 2 rows, 5 columns sequence_array_2_dim &lt;- array(1:10, dim= c(2,5)) sequence_array_2_dim # 3 dimensions - 2 rows, 5 columns, 2 tables sequence_array_3_dim &lt;- array(1:20, dim = c(2,5,2)) sequence_array_3_dim # 4 dimensions - 2 rows, 5 columns, 2 tables, 2 sets sequence_array_4_dim &lt;- array(1:40, dim = c(2,5,2,2)) sequence_array_4_dim Similar to vectors, functions can be applied to arrays: dim(sequence_array_2_dim) length(sequence_array_2_dim) sum(sequence_array_2_dim) max(sequence_array_2_dim) 2.4 Matrices Matrices are objects in which the elements are arranged in a two-dimensional rectangular layout. A matrix is created using the matrix() function: # A matrix is a 2-demensional (row x column) array A &lt;- matrix(1:25, 5, 5) B &lt;- matrix(1:25, 5, 5, byrow=TRUE) #if you want to fill down the row instead of across the columns C &lt;- matrix(1:5, 1, 5) D &lt;- matrix(1:5, 5, 1) Matrices are convenient because we can do linear algebra with them: # Element-wise operators A + B A - B A * B A / B # Matrix Multiplication C %*% D # Transpose C t(C) We can also name the matrix columns and and rows: colnames(A) &lt;- c(&quot;Column_1&quot;, &quot;Column_2&quot;, &quot;Column_3&quot;, &quot;Column_4&quot;, &quot;Column_5&quot;) A colnames(A)[4] &lt;- &quot;Changed_It&quot; A rownames(A) &lt;- c(&quot;Row_1&quot;, &quot;Row_2&quot;, &quot;Row_3&quot;, &quot;Row_4&quot;, &quot;Row_5&quot;) A We can also use some helpful functions for matrices: colSums(A) rowSums(A) sum(A) dim(A) length(A) And we can extract information from a matrix using similar index notation (row, column): A[2,1] # Single element A[,1] # All rows in the first column A[,c(1,2)] # All rows for columns 1 and 2 A[1,] # All columns in the first row A[c(1,2),] # All columns for rows 1 and 2 A[&quot;Row_1&quot;,&quot;Column_2&quot;] 2.5 Data Frames Data Frames are data displayed in a format as a table. A data frame is essentially a 2 dimensional matrix (row x column). You can think of it like an excel table or relational database table. Data Frames can have different types of data inside it, and we use the data.frame() function to create a data frame: # Create a data frame called dt1 from a set of vectors: dt1 &lt;- data.frame ( names = c(&quot;Simmons&quot;, &quot;Race&quot;, &quot;Healey&quot;, &quot;LaBarr&quot;, &quot;Villanes&quot;), class = c(&quot;Time Series&quot;, &quot;Linear Algebra&quot;, &quot;Visualization&quot;, &quot;Finance&quot;, &quot;Programming&quot;), female = c(1,1,0,0,1) ) To view the data frame: # View the table View(dt1) # Head of the table head(dt1, 3) To change the column names: colnames(dt1) colnames(dt1) &lt;- c(&quot;Last_Name&quot;, &quot;Class_Taught&quot;, &quot;Female?&quot;) colnames(dt1) colnames(dt1)[2] &lt;- &quot;Classes_Taught&quot; colnames(dt1) To reference a column by name: dt1$Last_Name dt1$Classes_Taught Data frame indexes - similar to vectors and arrays. We can perform the following actions: # Retrieve a row # leaving the row or column blank means &quot;everything&quot; # the negative operator &quot;-&quot; means &quot;everything but&quot; dt1[1,] dt1[2:5,] dt1[-1,] # Retrieve a column dt1[,1] dt1[,-3] dt1[,c(1:2)] dt1[,&quot;Last_Name&quot;] dt1[,c(&quot;Last_Name&quot;,&quot;Female?&quot;)] # Retrieve an element dt1[6,2] # Reassign an element dt1[5,2] &lt;- &quot;R Programming&quot; dt1[5,] #Find elements that meet a condition dt1$`Female?`==1 dt1$Last_Name==&#39;Race&#39; # Filter by an value dt1[dt1$`Female?`==1,] dt1[dt1$Last_Name==&#39;Race&#39;,] # Add a new row - rbind (row-bind) function. The cbind function is its column version. dt1 &lt;- rbind(dt1, c(&quot;Larsen&quot;, &quot;Teaching Assistant&quot;, 0)) dt1 # Add a new column dt1$First_Name &lt;- c(&quot;Susan&quot;, &quot;Shaina&quot;, &quot;Christopher&quot;, &quot;Aric&quot;, &quot;Andrea&quot;, &quot;Nicholas&quot;) # Change the order of columns dt1 &lt;- dt1[,c(4,1:3)] # Make columns based off other columns dt1$First_Name_Length &lt;- nchar(dt1$First_Name) dt1$Last_Name_Length &lt;- nchar(dt1$Last_Name) dt1$Total_Name_Length &lt;- dt1$First_Name_Length + dt1$Last_Name_Length + 1 dt1$Full_Name &lt;- paste(dt1$First_Name, dt1$Last_Name, sep=&quot; &quot;) dt1 # Remove some intermediate step columns dt1 &lt;- dt1[,-c(5,6)] 2.6 Working with different types We can examine the class of each object using the class function: total_add class(total_add) names class(names) l2 class(l2) sequence_array_1_dim class(sequence_array_1_dim) A class(A) dt1 class(dt1) dt1$First_Name class(dt1$First_Name) Finally, we can also do some conversions between them using the as functions: new_array &lt;- as.array(total_add) class(new_array) old_vector &lt;- as.vector(new_array) class(old_vector) dfA &lt;- as.data.frame(A) class(dfA) "]]
