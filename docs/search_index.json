[["programming-fundamentals.html", "Chapter 3 Programming Fundamentals 3.1 Logicals 3.2 Conditionals 3.3 Loops 3.4 Functions", " Chapter 3 Programming Fundamentals 3.1 Logicals A logical is a binary representation of True and False: &gt; a &lt;- TRUE &gt; &gt; b &lt;- FALSE &gt; &gt; typeof(b) Logicals are used for evaluating comparisons, such as: &gt; #equality &gt; # note the double equals == operator is a logical comparison, opposed to a single equal = being an assignment &gt; &gt; 2==2 &gt; typeof(2==2) &gt; &gt; &#39;cat&#39; == &#39;dog&#39; &gt; &gt; &#39;cat&#39; == &#39;cat&#39; &gt; &gt; #Not equal operator &gt; 2!=2 &gt; &gt; # greater than/less than &gt; 2&gt;2 &gt; &gt; 2&gt;=2 &gt; &gt; 2&lt;1 &gt; &gt; 2&lt;=1 &gt; &gt; # Null Values &gt; V1 &lt;- 1 &gt; V1[10] &lt;- 10 &gt; &gt; is.na(V1) &gt; !is.na(V1) &gt; &gt; # Contained within set &gt; V1 &gt; &gt; 1 %in% V1 &gt; 10 %in% V1 &gt; 2 %in% V1 &gt; &gt; &gt; c(1,2) %in% V1 &gt; &gt; # If we want not in, then use the not ! operator around the entire statement &gt; !(1 %in% V1) &gt; &gt; # Note, logicals can be used with other data types as well &gt; a &lt;- c(1,2,3,4,5) &gt; a &lt;= 1 &gt; &gt; b &lt;- c(1,2,7,9,5) &gt; a == b &gt; a != b &gt; &gt; A &lt;- matrix(1:10,2,5) &gt; B &lt;- matrix(seq(1,20,2),2,5) &gt; &gt; A == B &gt; A != B &gt; &gt; identical(a,b) &gt; identical(A,B) &gt; &gt; all.equal(A,B) 3.2 Conditionals Conditionals are expressions that perform different computations or actions depending on whether a predefined boolean condition is TRUE or FALSE. Conditionals allow us to control the flow of execution. We use logicals to evaluate conditional statements. Conditionals include if, else, ifelse. The syntax of if statement is: &gt; if (test_expression) { + statement + } If the test_expression is TRUE, the statement gets executed. But if it is FALSE, nothing happens. For example: &gt; x &lt;- 5 &gt; if(x &gt; 0){ + print(&quot;Positive number&quot;) + } If you will be executing a single statement after the conditional, you can withold the { } &gt; x &lt;- 5 &gt; if(x &gt; 0) print(&quot;Positive number&quot;) If we want code to execute when the test_expression is FALSE, then we add an else statement: &gt; if (test_expression) { + statement + } else { + statement2 + } For example: &gt; x &lt;- -5 &gt; if(x &gt; 0){ + print(&quot;Non-negative number&quot;) + } else { + print(&quot;Negative number&quot;) + } Note that you can use multiple logicals in the test_expression, such as: Or operator | And operator &amp; For example: &gt; mean_values &lt;- 3.1 &gt; std_dev_values &lt;- 1.95 &gt; &gt; if (mean_values&gt;=0 &amp; std_dev_values&gt;=1) { + print(paste(&quot;The mean&quot;, mean_values, &quot;is above 0, and the standard deviation&quot;, std_dev_values, &quot;is above 1&quot;)) + } Additionally, you can use the ifelse function to quickly assign a value based on a condition. The syntax for the ifelse function is ifelse(test_expression, yes, no). For example: &gt; std_dev_vector &lt;- c(1.2,0.8,0.3,2.4) &gt; ifelse(std_dev_vector&gt;=1, &quot;above one&quot;, &quot;below one&quot;) 3.3 Loops Occassionally, we need perform a task in an iterative cycle, also known as a loop. According to the R base manual, among the control flow commands, the loop constructs are for, while and repeat, with the additional clauses break and next. A for loop is used for iterating over a sequence (they iterate a defined number of times): &gt; sequence &lt;- seq(0,50,5) &gt; &gt; #Note this will iterate 11 times, the number of elements in &quot;sequence&quot; &gt; for(i in 1:length(sequence)){ + print(paste(&quot;Now at iteration&quot;, i, &quot;, value of sequence is&quot;, sequence[i])) + Sys.sleep(0.50) + } By default, R will iterate over all the elements in a vector without needing to designate a number &gt; for(value in sequence){ + print(paste(&quot;Value of sequence is&quot;, value)) + Sys.sleep(0.50) + } With the break statement, we can stop the loop before it has looped through all the items: &gt; for(i in 1:length(sequence)){ + if(i&gt;5) break + print(paste(&quot;Now at iteration&quot;, i, &quot;, value of sequence is&quot;, sequence[i])) + Sys.sleep(0.50) + } With the next statement, we can skip an iteration without terminating the loop: &gt; for(i in 1:length(sequence)){ + if((i %% 2)!=0) next + print(paste(&quot;Now at iteration&quot;, i, &quot;, value of sequence is&quot;, sequence[i])) + Sys.sleep(0.50) + } The while loops are used to loop until a specific condition is met: &gt; while (test_expression) + { + statement + } Here, test_expression is evaluated and the body of the loop is entered if the result is TRUE. The statements inside the loop are executed and the flow returns to evaluate the test_expression again. This is repeated each time until test_expression evaluates to FALSE, in which case, the loop exits. For example: &gt; #While loops - iterate so long as the condition is true &gt; #With while loops, it&#39;s important to set your starting conditions &gt; continue &lt;- TRUE &gt; i &lt;- 0 &gt; while(continue==TRUE){ + i = i + 1 + print(paste(&quot;At iteration&quot;, i, &quot;continue still set to&quot;, continue)) + if(i&gt;=5){ + continue &lt;- FALSE + print(paste(&quot;Iteration&quot;, i, &quot;reached. Continue set to&quot;, continue)) + print(paste(&quot;While loop terminated upon reaching iteration&quot;, i)) + } + Sys.sleep(0.50) + } A repeat loop is used to iterate over a block of code multiple number of times. There is no condition check in repeat loop to exit the loop. We must ourselves put a condition explicitly inside the body of the loop and use the break statement to exit the loop. Failing to do so will result into an infinite loop. &gt; repeat { + statement + } For example: &gt; x &lt;- 1 &gt; repeat { + print(x) + x = x+1 + if (x == 6){ + break + } + } Finally, we can nest loops of the same type or different types - for example, for every value of i it will do a loop of n: &gt; continue &lt;- TRUE &gt; i &lt;- 0 &gt; &gt; while(continue==TRUE){ + i = i + 1 + print(i) + if(i&gt;=5) continue &lt;- FALSE + + for(n in 1:3){ + print(paste(&quot;The value of i is&quot;, i, &quot;,and the value of n is&quot;, n)) + Sys.sleep(0.25) + } + + } 3.4 Functions A function is a set of statements organized together to perform a specific task. R has a large number of in-built functions and the user can create their own functions. An R function is created by using the keyword function. The basic syntax of an R function definition is as follows: &gt; function_name &lt;- function(arg_1, arg_2, arg_n) { + Function_Body + } An example of a custom function is the following: &gt; numbers &lt;- seq(1:10) &gt; &gt; calculator &lt;- function(data, type){ + if(type==&quot;mean&quot;){ + value &lt;- mean(data) + } else if (type==&quot;sum&quot;){ + value &lt;- sum(data) + } else if (type==&quot;min&quot;){ + value &lt;- min(data) + } else { + value &lt;- &quot;function not in calculator&quot; + } + return(value) + } &gt; &gt; calculator(numbers, &quot;mean&quot;) &gt; calculator(numbers, &quot;sum&quot;) &gt; calculator(numbers, &quot;min&quot;) &gt; calculator(numbers, &quot;max&quot;) To provide a default in the parameters, use the equal sign: &gt; calculator &lt;- function(data, type=&#39;mean&#39;){ + if(type==&quot;mean&quot;){ + value &lt;- mean(data) + } else if (type==&quot;sum&quot;){ + value &lt;- sum(data) + } else if (type==&quot;min&quot;){ + value &lt;- min(data) + } else { + value &lt;- &quot;function not in calculator&quot; + } + return(value) + } &gt; &gt; calculator(numbers) If we want to return multiple values, we need store them in a vector or list and return that object: &gt; univariate_summary &lt;- function(data){ + ntot &lt;- length(data) + mean &lt;- mean(data) + std &lt;- sd(data) + percentiles &lt;- quantile(data, probs=c(0, 0.25, 0.50, 0.75, 1)) + + l1 &lt;- list(n_obs=ntot, mean=mean, std=std, percentiles=percentiles) + return(l1) + } &gt; &gt; results &lt;- univariate_summary(numbers) &gt; results$percentiles &gt; results$std "]]
