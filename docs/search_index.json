[["data-wrangling.html", "Chapter 4 Data Wrangling 4.1 Libraries 4.2 Importing &amp; Exporting Data 4.3 dplyr and tidyverse 4.4 Data manipulation - dplyr basics 4.5 dplyr - pipe operator 4.6 stringr package 4.7 Combining Data - dplyr 4.8 Cheat Sheet 4.9 Extra - sqldf", " Chapter 4 Data Wrangling 4.1 Libraries Up until now, we havent used packages - only functions available in base R. However, the power of R truly exists in the libraries, which are sets of functions that any user can create and share. As of June 2019, there were over 14,000 packages available on the Comprehensive R Archive Network, or CRAN, the public clearing house for R packages. CRAN lists all libraries here: https://cran.r-project.org/web/packages/available_packages_by_name.html To install a library, you can either: Packages --&gt; Install --&gt; Name Use the function install.packages() Once a package is installed, you need to load it using the library or require function. These are the libraries well be using today. Install if you dont have: &gt; install.packages(c(&quot;data.table&quot;,&quot;dplyr&quot;,&quot;stringr&quot;)) Now, import the libraries: &gt; library(data.table) &gt; library(dplyr) &gt; library(stringr) 4.2 Importing &amp; Exporting Data Before importing data, we generally want to set the working directory. This is a folder where we will be accessing or storing data and outputs: &gt; setwd(&quot;C:/Users/avillan/Documents/Class 2022/Class_Code&quot;) Another useful function is getwd(). This function returns an absolute filepath representing the current working directory of the R process, or NULL if the working directory is not available: &gt; getwd() To import data, we can use the read. function &gt; df_auto &lt;- read.csv(&quot;Auto_MPG.csv&quot;, stringsAsFactors = FALSE) We can check the data set: &gt; class(df_auto) &gt; View(df_auto) &gt; dim(df_auto) &gt; nrow(df_auto) &gt; summary(df_auto) Note that Horsepower is a character class &gt; typeof(df_auto$Horsepower) &gt; df_auto$Horsepower &gt; summary(df_auto$Horsepower) Upon inspection, it read NAs as question marks (a character), so everything became a character. We can fix this by reassigning as numeric: &gt; df_auto$Horsepower &lt;- as.numeric(df_auto$Horsepower) &gt; summary(df_auto) &gt; df_auto$Horsepower &gt; summary(df_auto$Horsepower) Recall if you want to fix a column name you can use the colnames() function: &gt; colnames(df_auto) &gt; colnames(df_auto)[8] &lt;- &quot;Origin&quot; &gt; colnames(df_auto) If we want to export the data, we can use write.csv. The row.names = FALSE argument will stop the writer from outputting a row number: &gt; write.csv(df_auto, file=&quot;Auto_MPG_Clean.csv&quot;, row.names = FALSE) In addition to importing the data using code, one can also import data into RStudio with point-and-click. Go to Import Dataset in the Environment panel and select the relevant format. From there, you can set the datatype of each column, as well as specify whether to include or to skip a column or row. RStudio automatically generates the corresponding code that you can copy and paste for later reproducibility. 4.3 dplyr and tidyverse One of the most difficult (yet, interesting!) parts of open-source software is the many ways to achieve the same task. This can make recalling functions and syntax difficult, increasing the time to write or read code. Thus, people have started creating packages that structure coding tasks into a simple but comprehensive set of functions. Youll see this referred to as a grammar. This framework attempts to simplify the majority of required functions into a simple set of verbs to remember. If youre familiar with SQL - think about how easy it is to read and write: SELECT * FROM table WHERE column = 'some_value' In SQL, SELECT, FROM, WHERE are verbs that provide the framework for numerous tasks. The packages plyr, dplyr, ggplot2, stringr (and others) work within this framework. tidyverse is a collection of packages that encompases all of these https://www.tidyverse.org/ 4.4 Data manipulation - dplyr basics Select: select columns by name or helper function (choose which variables you want to look at ): &gt; select(df_auto, MPG, Cylinders) &gt; select(df_auto, -Origin) &gt; select(df_auto, contains(&quot;Model&quot;)) The base R equivalents are: &gt; df_auto$MPG &gt; df_auto[,c(&#39;MPG&#39;,&#39;Cylinders&#39;)] &gt; df_auto[,-c(&#39;Origin&#39;)] &gt; df_auto[,grepl(&quot;Model&quot;, names(df_auto))] Slice: Select rows by position (choose which rows of data you want): &gt; df_auto$row_number &lt;- 1:nrow(df_auto) #adding a new variable called row_number to help us see the index &gt; &gt; slice(df_auto,1:5) &gt; slice(df_auto, 150:n()) #all the rows between 150 and the end &gt; slice(df_auto, -1:-5) #removes rows between values, equivalent to slice(df_auto, 6:n()) &gt; &gt; df_auto &lt;- select(df_auto, -row_number) #remove the row_number column The base R equivalents are: &gt; df_auto[1:5,] &gt; df_auto[150:nrow(df_auto),] &gt; df_auto[-c(1:5),] Rename: Rename the columns of a data frame &gt; colnames(df_auto) &gt; &gt; df_auto &lt;- rename(df_auto, Miles_Per_Gallon=MPG) #rename MPG to Miles_Per_Gallon &gt; colnames(df_auto) &gt; &gt; df_auto &lt;- rename(df_auto, MPG=Miles_Per_Gallon) #rename back Miles_Per_Gallon to MPG &gt; colnames(df_auto) The base R equivalents are: &gt; colnames(df_auto)[1] &lt;- &#39;Miles_Per_Gallon&#39; &gt; colnames(df_auto) &gt; &gt; colnames(df_auto)[1] &lt;- &#39;MPG&#39; &gt; colnames(df_auto) Filter: Extract rows that meet logical criteria (filter the data frame by one, or multiple, conditions) &gt; filter(df_auto, MPG&gt;20) &gt; filter(df_auto, (MPG&gt;20 &amp; Acceleration&gt;20)) &gt; filter(df_auto, MPG==max(MPG)) &gt; filter(df_auto, MPG==min(MPG)) The base R equivalents are: &gt; df_auto[df_auto$MPG&gt;20,] &gt; df_auto[(df_auto$MPG&gt;20 &amp; df_auto$Acceleration&gt;20),] &gt; df_auto[which.max(df_auto$MPG),] &gt; df_auto[which.min(df_auto$MPG),] Sample: Randomly select a sample of n size or a proportion &gt; sample_n(df_auto, 5) &gt; sample_frac(df_auto, 0.05) The base R equivalents are: &gt; df_auto[sample(1:nrow(df_auto),5),] &gt; df_auto[sample(1:nrow(df_auto),ceiling(0.05*nrow(df_auto))),] Mutate: Compute and append one or more new columns (create a new variable - returns the data frame) &gt; mutate(df_auto, HP_Per_Cylinder=Horsepower/Cylinders) &gt; mutate(df_auto, Avg_HP_Per_Cylinder = mean(Horsepower/Cylinders, na.rm=TRUE)) The base R equivalents are: &gt; df_auto$HP_Per_Cylinder &lt;- df_auto$Horsepower / df_auto$Cylinders &gt; df_auto$Avg_HP_Per_Cylinder &lt;- mean(df_auto$Horsepower / df_auto$Cylinders, na.rm = TRUE) About the na.rm=TRUE argument. Some arithmatic functions sum, avg, count, etc. will NA the entire column if they encounter a single NA within that column/vector. Setting na.rm=TRUE will tell the interpreter to remove the NA and carry forth with the calculation. Summarise: Summarise data into single row of values (aggregates the data into a single result. think avg, mean, min, max, etc.) &gt; summarise(df_auto, + Avg_HP_Per_Cylinder=mean(Horsepower/Cylinders, na.rm = TRUE), + Min_HP_Per_Cylinder=min(Horsepower/Cylinders, na.rm=TRUE) + ) The base R equivalents are: &gt; data.frame( + Avg_HP_Per_Cylinder = mean(df_auto$Horsepower/df_auto$Cylinders, na.rm = TRUE), + Min_HP_Per_Cylinder = min(df_auto$Horsepower/df_auto$Cylinders, na.rm=TRUE) + ) 4.5 dplyr - pipe operator Consider the previous operations. If we wanted to manipulate our data set in order, we traditionally have to do a reassignment each time: &gt; ddf_auto_hold &lt;- rename(df_auto, Miles_Per_Gallon=MPG) #rename &gt; &gt; df_auto_hold &lt;- mutate(df_auto_hold, HP_Per_Cylinder=Horsepower/Cylinders) #then create &gt; &gt; df_auto_hold &lt;- filter(df_auto_hold, HP_Per_Cylinder&gt;20) #then filter &gt; &gt; df_auto_hold &lt;- select(df_auto_hold, Car_Name, HP_Per_Cylinder) #then select &gt; &gt; View(df_auto_hold) This is truely cumbersome the more complicated the data manipulation becomes. To avoid this, we can use the pipe operator %&gt;%. The pipe passes along the results of one function to the next: &gt; df_auto_hold &lt;- df_auto %&gt;% #note the pipe operator + rename(Miles_Per_Gallon=MPG) %&gt;% #note the first argument is not required, because the pipe is passing it + mutate(HP_Per_Cylinder=Horsepower/Cylinders) %&gt;% + filter(HP_Per_Cylinder&gt;20) %&gt;% + select(Car_Name, HP_Per_Cylinder) &gt; &gt; View(df_auto_hold) 4.6 stringr package The package stringr is a similar grammar language for manipulating strings. All the functions start with str_ Consider that I want to extract the Car Make and Model from the Car Name: &gt; View(df_auto_hold) We note that the first word in Car_Name is the make, and the second word is the model. The str_split function will split the string into a vector of individual tokens: &gt; df_auto_hold &lt;- df_auto %&gt;% + mutate(Car_Make=str_split(Car_Name,&quot; &quot;)) &gt; &gt; View(df_auto_hold) The str_split creates a list, which we can use to try to get the value: &gt; df_auto_hold &lt;- df_auto %&gt;% + mutate(Car_Make=str_split(Car_Name,&quot; &quot;)[[1]][1]) &gt; View(df_auto_hold) Note, this is treating the entire column, instead of by row. One way to address this is to rowise() by Car_Name, then create the variable: &gt; df_auto_hold &lt;- df_auto %&gt;% + rowwise() %&gt;% + mutate(Car_Make=str_split(Car_Name,&quot; &quot;)[[1]][1]) &gt; &gt; View(df_auto_hold) An alternative to this group_by is the group_by() function: &gt; df_auto_hold &lt;- df_auto %&gt;% + group_by(Car_Name) %&gt;% + mutate(Car_Make=str_split(Car_Name,&quot; &quot;)[[1]][1]) &gt; &gt; View(df_auto_hold) With the structure built, I can just pipe on more functions to get additional variables: &gt; df_auto &lt;- df_auto %&gt;% + rowwise() %&gt;% + mutate(Car_Make=str_split(Car_Name,&quot; &quot;)[[1]][1]) %&gt;% + mutate(Car_Model=paste(str_split(Car_Name,&quot; &quot;)[[1]][-1], collapse=&quot; &quot;)) #everything but the first &gt; &gt; View(df_auto) Now that we have Car Make and Model, we might want to summarize some information. We saw summarize the entire column earlier, but we can additionally summarize by a group. We use the group_by() to do so: &gt; # Average MPG by Make and Model Year &gt; df_auto %&gt;% + group_by(Car_Make, Model_Year) %&gt;% + summarise(Average_MPG=mean(MPG)) %&gt;% + arrange(Model_Year) %&gt;% + filter(Model_Year==70) %&gt;% + ungroup(Car_Make, Model_Year) What if we want to create a variable for each Make that is the average MPG across the Make, by year? &gt; df_auto_hold &lt;- df_auto %&gt;% + group_by(Car_Make, Model_Year) %&gt;% + mutate(Average_MPG=mean(MPG)) %&gt;% #create a column that contains the avg MPG for the model year of the car + mutate(MPG_Fold_Pct=round(((MPG-Average_MPG)/Average_MPG)*100,2)) %&gt;% + ungroup(Car_Make, Model_Year) %&gt;% + arrange(Car_Make, Model_Year) %&gt;% + select(Car_Make, Model_Year, Car_Name, MPG, Average_MPG, MPG_Fold_Pct) &gt; &gt; View(df_auto_hold) 4.7 Combining Data - dplyr Typically when working with data, especially relational databases, we have information stored in multiple tables. For instance, we have the Auto data set: &gt; View(df_auto) &gt; &gt; # But we also have data on when a brand started: &gt; Car_Make &lt;- c(&quot;amc&quot;, &quot;audi&quot;, &quot;bmw&quot;, &quot;buick&quot;, &quot;chevrolet&quot;, &quot;datsun&quot;, &quot;dodge&quot;, &quot;ford&quot;) &gt; First_Year &lt;- c(1954, 1910, 1916, 1903, 1911, 1931, 1900, 1903) &gt; &gt; df_auto_start &lt;- data.frame(Car_Make=Car_Make, + First_Year=First_Year, + stringsAsFactors = FALSE) &gt; &gt; View(df_auto_start) We are interested in the relationship between founding year and average MPG for the max year. For this, we need to get my First Year data combined with the Auto MPG Data. This is accomplished via joins. Dplyr has different join types. The easiest way to think about this is as a Venn-Diagram. inner_join - only returns the data where both frames contain the join key(s), removes all non-matching rows left_join - maintains all of the data on base table (left/top), and joins matching data from the joining table. NAs created for joining table right_join - opposite of left. Maintains all of the data on the joining table and matches from the base table. NAs created for base table full_join - returns all data from both tables. NAs created for both tables. Inner_join: &gt; df_auto_hold &lt;- df_auto %&gt;% + inner_join(df_auto_start, by=&quot;Car_Make&quot;) &gt; &gt; View(df_auto_hold) &gt; &gt; # Note, we&#39;ve effectively filtered a lot of data because the inner_join only keeps matching records. &gt; dim(df_auto) &gt; dim(df_auto_hold) &gt; &gt; # Joins can pipe together with other functions just as we expect &gt; df_auto_hold &lt;- df_auto %&gt;% + inner_join(df_auto_start, by=&quot;Car_Make&quot;) %&gt;% + group_by(Car_Make, First_Year) %&gt;% + summarise(Average_MPG=mean(MPG)) &gt; &gt; View(df_auto_hold) &gt; &gt; plot(df_auto_hold$First_Year, df_auto_hold$Average_MPG) Left_join: &gt; df_auto_hold &lt;- df_auto %&gt;% + left_join(df_auto_start, by=&quot;Car_Make&quot;) &gt; &gt; # note, we&#39;ve retained all of the records but it&#39;s placed &quot;NA&quot; in the column where it couldn&#39;t find a matching record &gt; dim(df_auto) &gt; dim(df_auto_hold) &gt; &gt; is.na(df_auto_hold$First_Year) &gt; &gt; View(df_auto_hold) &gt; &gt; df_auto_hold &lt;- df_auto %&gt;% + left_join(df_auto_start, by=&quot;Car_Make&quot;) %&gt;% + group_by(Car_Make, First_Year) %&gt;% + summarise(Average_MPG=mean(MPG)) &gt; &gt; View(df_auto_hold) 4.8 Cheat Sheet Were not going to cover every function here, but what is great about these packages is the the cheatsheets. The community has made to provide reference. I highly recommend downloading them and keeping them close: dplyr: https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf stringr: https://github.com/rstudio/cheatsheets/blob/master/strings.pdf a whole lot more https://www.rstudio.com/resources/cheatsheets/ 4.9 Extra - sqldf If you like SQL, there is a package allows you to manipulate data in a in-memory, or permanent database: &gt; install.packages(&quot;sqldf&quot;) &gt; library(sqldf) &gt; &gt; df_auto_hold &lt;- sqldf(&quot;select * from df_auto where Car_Make=&#39;amc&#39;&quot;) &gt; View(df_auto_hold) We will learn a lot more about SQL in the Fall semester. "]]
