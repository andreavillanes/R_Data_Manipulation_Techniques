# Data Structures

## Vectors

A vector is the simplest type of data structure in R. Vectors are particularly important as most of the functions you will write will work with vectors. Simply put, a vector is a sequence of data elements of the same basic type. 

We can construct a vector using the combine `(c)` function:

```{r prompt=TRUE, eval=FALSE}
  # Here is a vector containing three numeric values 3, 5 and 7:
  numbers <- c(3, 5, 7)

  #Here is a vector of logical values:
  logical <- c(TRUE, FALSE, TRUE, FALSE, FALSE) 
  
  #Here is a vector of character values:
  fruits <- c("apple", "oranges", "banana")
```

We can also change the value in a vector:

```{r prompt=TRUE, eval=FALSE}
  fruits[2] <- "strawberries"
```

Every vector has two key properties: its type and its length:

```{r prompt=TRUE, eval=FALSE}
  typeof(fruits)
  length(fruits)
```

You can combine vectors using the combine function as well:

```{r prompt=TRUE, eval=FALSE}
  results <- c(1, 2, 3)
  other_results <- c(4, 5, 6)
  combined_results <- c(results, other_results)
```

Vectors can be added together in an element-wise operation:

```{r prompt=TRUE, eval=FALSE}
  total_add <- results + other_results
  total_div <- results / other_results
  total_mod <- results %% other_results
```


Functions can be applied to each element of the vector. However, not all functions are vectorized (we will cover this later):

```{r prompt=TRUE, eval=FALSE}
  total_rou <- round(total_div, 1)

  names <- c("Simmons", "Race", "Healey", "LaBarr", "Villanes")
  names <- sort(names, decreasing = TRUE)
```

There are also functions for constructing useful types of vectors:

```{r prompt=TRUE, eval=FALSE}
  # Replicate - replicates a value X number of times 
  identity_vector <- rep(1,10)
  identity_vector
  
  # Sequence operator ":" From:To 
  sequence_vector <- 1:10
  
  # Sequence function - allows sequencing by a value
  sequence_by_two_vector <- seq(0,10, 2)
  sequence_by_two_vector
  
  # Sample function - take a random sample from a vector
  random_vector <- sample(sequence_by_two_vector,3)
```

Finally, a vector doesn't have to be made with consistent elements, but it will force them to one type:

```{r prompt=TRUE, eval=FALSE}
  values <- c("IAA", 1, "2021", 5)
  typeof(values)
```

As we mentioned earlier, the elements of a vector can only be of one type. If we want elements of different types... we will need a list.

## Lists

Lists are objects which contain elements of different types like âˆ’ numbers, strings, vectors and another list inside it. A list can also contain a matrix or a function as its elements. A list is created using list() function.

```{r prompt=TRUE, eval=FALSE}
  # Here are 3 vectors of different types
  v1 <- c("apple", "banana")
  v2 <- c("dog", "cat", "bunny", "pig", "cow", "horse")
  v3 <- seq(0,10,by=2)
  
  v1;v2;v3
```

We can put all of these vectors into a list:

```{r prompt=TRUE, eval=FALSE}
  # Here are 3 vectors of different types
  l1 <- list(v1, v2, v3)

  class(l1)
  typeof(l1)  
```

List elements can be accessed via index. Each of the components of a list is accessed via the double bracket [[x]] syntax:

```{r prompt=TRUE, eval=FALSE}
  # First element in the list
  l1[[1]]
  
  # First element in the first element (vector) of the list
  l1[[1]][1]
```

List elements can be named:

```{r prompt=TRUE, eval=FALSE}
  names(l1) <- c("Fruit", "Animals", "Even_Numbers")
```

Or they can be named upon creating the list:

```{r prompt=TRUE, eval=FALSE}
  l1 <- list(Fruit=v1, Animals=v2, Even_Numbers=v3)
```

The elements in a list can be retrieved by name:

```{r prompt=TRUE, eval=FALSE}
  l1$Fruit
  l1$Fruit[1]
  
  l1$Even_Numbers
  max(l1$Even_Numbers)
```

A list can even contain lists:

```{r prompt=TRUE, eval=FALSE}
  l2 <- list(Odd_Numbers=seq(1,10,by=2), list1=l1)

  # First Vector
  l2$Odd_Numbers
  l2[[1]]
  
  # l1 within L2
  l2$list1
  l2[[2]]
  
  l2$list1$Fruit
  l2[[2]][1]
  
  l2$list1$Fruit[1]
  l2[[2]][[1]][1]
  
  l2[[2]][[1]][3] <- "blueberry"
  l2$list1$Fruit
  l2
```

To combine lists:

```{r prompt=TRUE, eval=FALSE}
  l4 <- list(More_Fruit=c("melon", "orange"))
  l1 <- c(l1,l4)
```

Finally, if we want to update part of a list, we can just operate on and update it accordingly:

```{r prompt=TRUE, eval=FALSE}
  l1$Fruit <- c(l1$Fruit, l4$More_Fruit)
  l1$Fruit
```

## Arrays
Arrays are similar to vectors, except that they are multi-dimensional. An array is created using the array() function, and the dim parameter to specify the dimensions:

```{r prompt=TRUE, eval=FALSE}
  # 1 dimension - 1 row (vector)
  sequence_array_1_dim <- array(1:10, dim=10)
  sequence_array_1_dim
  
  # 2 dimensions - 2 rows, 5 columns 
  sequence_array_2_dim <- array(1:10, dim= c(2,5))
  sequence_array_2_dim
  
  # 3 dimensions - 2 rows, 5 columns, 2 tables
  sequence_array_3_dim <- array(1:20, dim = c(2,5,2))
  sequence_array_3_dim
  
  # 4 dimensions - 2 rows, 5 columns, 2 tables, 2 sets 
  sequence_array_4_dim <- array(1:40, dim = c(2,5,2,2))
  sequence_array_4_dim
```

Similar to vectors, functions can be applied to arrays:

```{r prompt=TRUE, eval=FALSE}
  dim(sequence_array_2_dim)
  length(sequence_array_2_dim)
  sum(sequence_array_2_dim)
  max(sequence_array_2_dim)
```

## Matrices

## Data Frames

## Working with different types
